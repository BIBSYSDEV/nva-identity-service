plugins {
    id 'java-library'
    id 'jacoco'
    id 'checkstyle'
    id 'pmd'
    id "nebula.lint" version "17.2.1"
    id 'maven-publish'
    id 'base'
}

allprojects {
    apply plugin: 'maven-publish'
    apply plugin: 'nebula.lint'
    apply plugin: 'base'

    project.ext {
        nvaCommonsVersion = '1.10.0'
        awsSdkVersion ="1.12.59"
        jacksonVersion ="2.10.3"
        xraySdkVersion = '2.9.1'
        DynamoDBLocalVersion = '1.15.0'
        nvaTestUtilsVersion = '0.1.13'
        zalandoProblemVersion = '0.25.0'
        awsLambdaCoreVersion = '1.2.1'

    }

    gradleLint {
        rules  = ['all-dependency']
    }

    repositories {
        mavenCentral()
        maven { url 'https://jitpack.io' }
        maven { url "https://s3.eu-central-1.amazonaws.com/dynamodb-local-frankfurt/release" }
    }
}

subprojects {
    task allDeps(type: DependencyReportTask) {}

    apply plugin: 'java-library'
    apply plugin: 'jacoco'
    apply plugin: 'checkstyle'
    apply plugin: 'pmd'

    final def jupiterVersion = "5.6.0"

    dependencies {
        implementation group: 'com.github.bibsysdev', name: 'core', version: project.ext.nvaCommonsVersion

        implementation group: 'com.amazonaws', name: 'aws-xray-recorder-sdk-core', version: project.ext.xraySdkVersion
        implementation group: 'com.amazonaws', name: 'aws-xray-recorder-sdk-aws-sdk', version: project.ext.xraySdkVersion
        implementation group: 'com.amazonaws', name: 'aws-xray-recorder-sdk-aws-sdk-instrumentor', version: project.ext.xraySdkVersion

        testImplementation group: 'com.github.BIBSYSDEV', name: 'nva-testutils', version: project.ext.nvaTestUtilsVersion
        testImplementation group: 'com.amazonaws', name: 'DynamoDBLocal', version: project.ext.DynamoDBLocalVersion
        testImplementation group: 'org.mockito', name: 'mockito-core', version: '3.3.3'
        testImplementation('org.zalando:problem:0.24.0') {
            dependencies {
                compileOnly(group: 'org.apiguardian', name: 'apiguardian-api', version: '1.1.0') {
                    because 'Dependency has maven scope provided'
                }
            }

        }
        testRuntimeOnly group: 'org.junit.jupiter', name: 'junit-jupiter-engine', version: jupiterVersion
        testImplementation group: 'org.junit.jupiter', name: 'junit-jupiter-api', version: jupiterVersion
        testImplementation group: 'org.junit.jupiter', name: 'junit-jupiter-migrationsupport', version: jupiterVersion
        testImplementation group: 'org.junit.jupiter', name: 'junit-jupiter-params', version: jupiterVersion
        testImplementation group: 'org.hamcrest', name: 'hamcrest', version: '2.2'


    }

    test {
        useJUnitPlatform()
        failFast = true
        testLogging {
            events('skipped', 'passed', 'failed')
        }
        final Map<String, String> envVariables = new HashMap<>()
        envVariables.put("ALLOWED_ORIGIN", "*")
        environment(envVariables)
        finalizedBy jacocoTestReport
    }

    pmd {
        ruleSetConfig = rootProject.resources.text.fromFile('config/pmd/ruleset.xml')
        toolVersion = "6.33.0"
        ruleSets = []
        ignoreFailures = false
    }

    checkstyle {
        configFile = rootProject.resources.text.fromFile('config/checkstyle/checkstyle.xml').asFile()
        showViolations = true
    }

    tasks.withType(Checkstyle) {
        reports {
            xml.enabled false
            html.enabled true
            html.stylesheet rootProject.resources.text.fromFile('config/checkstyle/checkstyle-simple.xsl')
        }
    }

    // jacoco configuration
    check.dependsOn jacocoTestCoverageVerification
    jacocoTestCoverageVerification.dependsOn(jacocoTestReport)

    jacocoTestCoverageVerification {
        violationRules {
            rule {
                limit {
                    counter = 'METHOD'
                    value = 'COVEREDRATIO'
                    minimum = 1.000
                }
            }
            rule {
                limit {
                    counter = 'CLASS'
                    value = 'COVEREDRATIO'
                    minimum = 1.000
                }
            }
        }
    }

    // publish submodules
    task sourcesJar(type: Jar, dependsOn: classes) {
        archiveClassifier = 'sources'
        from sourceSets.main.allSource
    }

    artifacts {
        archives sourcesJar
    }

}


def getProjectList() {
    // These projects are considered. Replace with a different list as needed.
    subprojects + project
}

task jacocoMerge(type: JacocoMerge) {
    group = LifecycleBasePlugin.VERIFICATION_GROUP
    description = 'Merge the JaCoCo data files from all subprojects into one'
    project.afterEvaluate {  // do it at the end of the config phase to be sure all information is present
        FileCollection execFiles = project.objects.fileCollection()   // an empty FileCollection
        getProjectList().each { Project subproject ->
            if (subproject.pluginManager.hasPlugin('jacoco')) {
                def testTasks = subproject.tasks.withType(Test)
                dependsOn(testTasks)   // ensure that .exec files are actually present

                testTasks.each { Test task ->
                    // The JacocoTaskExtension is the source of truth for the location of the .exec file.
                    JacocoTaskExtension extension = task.getExtensions().findByType(JacocoTaskExtension.class)
                    if (extension != null) {
                        execFiles.from extension.getDestinationFile()
                    }
                }
            }
        }
        executionData = execFiles
    }
    doFirst {
        // .exec files might be missing if a project has no tests. Filter in execution phase.
        executionData = executionData.filter { it.canRead() }
    }
}

def getReportTasks(JacocoReport pRootTask) {
    getProjectList().collect {
        it.tasks.withType(JacocoReport).findAll { it != pRootTask }
    }.flatten()
}

task jacocoRootReport(type: JacocoReport, dependsOn: tasks.jacocoMerge) {
    group = LifecycleBasePlugin.VERIFICATION_GROUP
    description = 'Generates an aggregate report from all subprojects'

    logger.lifecycle 'Using aggregated file: ' + tasks.jacocoMerge.destinationFile
    executionData.from tasks.jacocoMerge.destinationFile

    project.afterEvaluate {
        // The JacocoReport tasks are the source of truth for class files and sources.
        def reportTasks = getReportTasks(tasks.jacocoRootReport)
        classDirectories.from project.files({
            reportTasks.collect {it.classDirectories}.findAll {it != null}
        })
        sourceDirectories.from project.files({
            reportTasks.collect {it.sourceDirectories}.findAll {it != null}
        })
    }

    reports {
        xml.enabled true
    }
}

build {
    dependsOn jacocoRootReport
}
